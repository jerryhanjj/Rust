# 所有权规则

1. Rust 中的每一个值都有一个 所有者（owner）。
2. 值在任一时刻有且只有一个所有者。
3. 当所有者（变量）离开作用域，这个值将被丢弃。

## Rust内存释放策略
内存在拥有它的变量离开作用域后就被自动释放

## 变量与数据交互的方式

### 移动

### 拷贝

- 所有整数类型，比如 u32
- 布尔类型，bool，它的值是 true 和 false
- 所有浮点数类型，比如 f64
- 字符类型，char
- 元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有

## 引用与借用

创建一个引用（references）的行为称为 借用（borrowing）

一个引用的作用域从声明的地方开始一直持续到最后一次使用为止

可变引用的限制：
- 如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用，防止同一时间对同一数据存在多个可变引用
- 不能同时使用可变与不可变引用

限制的好处：在编译时就避免数据竞争

数据竞争（data race）类似于竞态条件，它可由这三个行为造成：
- 两个或更多指针同时访问同一数据
- 至少有一个指针被用来写入数据
- 没有同步数据访问的机制

综述：
```
1. 在任意给定时间，要么 只能有一个可变引用，要么 只能有多个不可变引用。
2. 引用必须总是有效的
```

## Slice类型

slice 允许你引用集合中一段连续的元素序列，而不用引用整个集合

***slice分割字符串的索引是字节的位置，不是字符的位置，因此，在处理多字节字符时要注意在切片时索引位于字符边界上***

### s.char_indices()、s.chars().enumerate()


`s.char_indices()` 和 `s.chars().enumerate()` 都可以用来迭代字符串中的字符及其索引，但它们之间有一个重要的区别：

#### `s.char_indices()`

- `char_indices()` 方法返回一个迭代器，该迭代器产生一个元组 `(usize, char)`，其中 `usize` 是字符在字符串中的字节索引，`char` 是字符本身。
- 这个方法直接提供了字符的字节索引，这对于创建字符串切片非常有用，因为字符串切片是基于字节索引的。

#### `s.chars().enumerate()`

- `chars()` 方法返回一个迭代器，该迭代器产生字符串中的每个字符。
- `enumerate()` 方法可以应用于任何迭代器，包括 `chars()` 返回的迭代器。它返回一个迭代器，该迭代器产生一个元组 `(usize, T)`，其中 `usize` 是元素的索引（从0开始），`T` 是迭代器中的元素类型，在这个例子中是 `char`。
- 这里的索引是基于字符的枚举索引，而不是字节索引。这意味着如果字符串包含多字节字符，`enumerate()` 方法返回的索引将不会与字符在字符串中的字节位置相对应。

#### 示例

让我们通过一个包含多字节字符的字符串示例来说明这两者的区别：

```rust
let s = "hello 🌍";

// 使用 char_indices
for (i, c) in s.char_indices() {
    println!("char_indices: Index: {}, Char: {}", i, c);
}

// 使用 chars().enumerate()
for (i, c) in s.chars().enumerate() {
    println!("chars().enumerate(): Index: {}, Char: {}", i, c);
}
```

输出可能如下：

```
char_indices: Index: 0, Char: h
char_indices: Index: 1, Char: e
char_indices: Index: 2, Char: l
char_indices: Index: 3, Char: l
char_indices: Index: 4, Char: o
char_indices: Index: 6, Char:  
chars().enumerate(): Index: 0, Char: h
chars().enumerate(): Index: 1, Char: e
chars().enumerate(): Index: 2, Char: l
chars().enumerate(): Index: 3, Char: l
chars().enumerate(): Index: 4, Char: o
chars().enumerate(): Index: 5, Char:  
```

注意 `char_indices` 方法返回的最后一个字符的索引是 6，因为 "🌍" 是一个多字节字符，它的字节索引从 6 开始。而 `chars().enumerate()` 方法返回的索引是基于字符的枚举索引，最后一个字符的索引是 5。

#### 总结

- 使用 `char_indices()` 可以获得字符的字节索引，这对于字符串切片操作非常有用。
- 使用 `chars().enumerate()` 可以获得字符的枚举索引，这在处理字符时很有用，但不适用于字符串切片操作。


### String和str的区别

AI解答内容：
```
在 Rust 中，`String` 和 `str` 是两种不同的字符串类型，它们在内存管理、可变性和用途上有所区别：

### `String`

- **`String` 是一个拥有所有权的字符串类型**：它是一个可增长、可变、拥有所有权的字符串类型。当你创建一个 `String` 时，它在堆上分配内存来存储字符串数据。
- **可变性**：`String` 类型是可变的，这意味着你可以在不违反 Rust 借用规则的情况下修改 `String` 的内容（例如，添加更多的字符）。
- **动态大小**：`String` 可以在运行时增长或缩小，因为它在堆上分配内存。
- **使用场景**：当你需要一个可变的、拥有所有权的字符串时，使用 `String`。例如，当你需要从文件中读取数据并将其存储为字符串时。

### `str`

- **`str` 是一个字符串切片类型**：它是一个不可变的字符串视图，通常是一个指向其他字符串数据的切片。`str` 类型的值不拥有它所引用的字符串数据。
- **不可变性**：`str` 类型是不可变的，这意味着你不能修改 `str` 的内容。
- **固定大小**：`str` 的大小在编译时是已知的，因为它只是一个指向字符串数据的指针和长度。
- **使用场景**：当你只需要读取字符串数据而不需要拥有或修改它时，使用 `str`。例如，字符串字面量、函数参数类型（为了灵活性）等。

### 转换

- 你可以通过 `&` 运算符从 `String` 获取一个 `&str` 类型的切片。
- 你可以使用 `to_string` 方法或 `String::from` 函数从 `&str` 创建一个 `String`。

### 总结

- **所有权**：`String` 拥有它所存储的字符串数据，而 `str` 只是一个指向其他地方的字符串数据的不可变引用。
- **可变性**：`String` 是可变的，`str` 是不可变的。
- **用途**：`String` 用于需要可变性和所有权的场景，`str` 用于只需要读取字符串的场景。

这些区别使得 `String` 和 `str` 在不同的上下文中有各自的优势和用途。
```
